[
  {
    "path": "tutorials/01/",
    "title": "01. Building Graphs Layer by Layer",
    "description": "This tutorial is a gentle introduction to ggplot2, one of the most successful\nsoftware packages for producing statistical graphics, created by Hadley\nWickham based on the \"Grammar of Graphs\" by Leland Wilkinson. It provides a\nsimple set of core principles, with carefully chosen defaults, to enable\nquick prototyping as well as publication-quality graphics. In what follows,\nwe will familiarize ourselves with the fundamental concepts and elements of\nevery ggplot2 graphic: how to create a plot object, add data, create a\nmapping to some aesthetics, and add layers of visual marks.",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Chapter 2"
    ],
    "contents": "\n\nContents\nPreliminaries\nWorkflow\nReading the documentation\nRequired packages\n\nData\nMain components\nMore aesthetics\nFaceting\nOutput\n\nSource: _tutorials/01/01.Rmd\nPreliminaries\nThis tutorial is heavily based on the First steps introductory chapter from the ggplot2 book. The best way to follow this tutorial is by using the RStudio IDE, so ensure that you have it installed in your computer (along with R).\nWorkflow\nTo start with, let’s create a new project by clicking on File > New Project.... Follow the steps to give it a sensible name (e.g., “dataviz”) and place it under a proper path in your computer. This creates a new folder where you can save all your files (scripts, plots, data…) related to this course, preferably organized following some logic (e.g., all scripts under a scripts subdirectory, etc.). Now, whenever you return to your project (if you close and open RStudio again, your last project is automatically opened; otherwise, click File > Recent Projects > ...), RStudio automatically sets the working directory (both of the file manager as well as the R session) to the project folder.\nOnce you open a new script (File > New File > R Script), the interface is divided in four sections:\nEditor (top-left), where you can edit the script file.\nConsole (bottom-left), where you can execute R commands in the current R session.\nEnvironment (top-right), where you can inspect the variables defined in the current R session.\nFiles / Plots / Packages / Help / Viewer (bottom-right), where you can browse your files, show your plots, inspect the installed packages, read the manual pages…\nSave that empty script (Ctrl + S) using a sensible name (e.g., 01-building_graphs_layer_by_layer.R) in your project folder (or some subfolder according to your organization logic).\nNow, the recommended workflow is to copy the chunks of code you’ll find in this tutorial into your script, and there you can run it (by selecting some lines and hitting Ctrl + Enter, or just hitting Ctrl + Enter sequentially to run code line by line), modify it, and try again. Be sure to save your progress with some frequency, just in case, and to comment your code (# comments starts with a hashtag like this). Future-you will thank you.\nAnother option would be to download the sources of this Rmd document, and use it to tinker with the chunks of code directly.\nReading the documentation\nA very important skill for every programming language is learning how to read its documentation. In R, we can quickly open the manual page for any function just by typing ?name-of-the-function in the console, for example, ?mean (try this yourself). Then, you’ll always find the same structure, more or less:\nDescription of the function, what the function does.\nUsage, how to call the function, sometimes with different objects.\nArguments, the description of every argument shown in the usage section.\nValue, what the function returns.\nOptionally, other sections with more details.\nOptionally, References.\nOptionally, a list of related functions called See Also.\nOptionally, but usually, Examples of usage.\nCheckpoint 1\nEnsure that you have\ncreated a new project for the course;\ncreated a new script in your project for this tutorial;\nlocated all the relevant panels and parts of the IDE;\nfigured out how to save the file;\nfigured out how to send the code from the script to the console for execution;\nbecome accustomed to the documentation.\nRequired packages\nFor this tutorial, we need these packages (run the following to install them if you don’t have them already):\n\n\ninstall.packages(\"ggplot2\")\n\n\nData\nIn this tutorial, we will mostly use one data set that is bundled with ggplot2: mpg. It includes information about the fuel economy of popular car models in 1999 and 2008, collected by the US Environmental Protection Agency.\n\n\nlibrary(ggplot2)\nmpg\n\n\n\n\nThe variables are mostly self-explanatory:\ncty and hwy record miles per gallon (mpg) for city and highway driving.\ndispl is the engine displacement in litres.\ndrv is the drivetrain: front wheel (f), rear wheel (r) or four wheel (4).\nmodel is the model of car. There are 38 models, selected because they had a new edition every year between 1999 and 2008.\nclass is a categorical variable describing the “type” of car: two seater, SUV, compact, etc.\nMain components\nThere are three main components to every ggplot:\nThe data in tidy format.\nA set of mappings from data attributes (variables) to visual channels (aesthetics).\nAt least one layer of visual marks to represent the observations in the dataset, which is usually created with a geom function.\nEvery ggplot starts with the object creation, via the ggplot() function:\n\n\nggplot()\n\n\nAs you can see, this generates just an empty frame: there is no data, no mappings, and therefore no guides or other elements. Even if we add some data, there are still nothing connecting it to any visual feature:\n\n\nggplot(mpg)\n\n\nNext, we can add some mappings. For instance, if we are interested in the relationship between miles per gallon in highway driving (hwy) vs. the engine displacement (displ), we would assign those attributes to y and x positions respectively using the aes() function:\n\n\nggplot(mpg, aes(x=displ, y=hwy))\n\n\nNow we obtained something new. Now, because there is data and mappings to x and y positions, ggplot2 applies some sensible defaults, and automatically adds Cartesian coordinates as well as linear continuous scales that nicely fit to the range of our data (you can check this with e.g. range(mpg$hwy)). Moreover, these scales display nicely formatted guides, with labeled ticks at regular intervals (not too many, not too few), major and minor grid lines, and axis labels after the names of our variables.\nWhat is missing here? Of course, the most important bit, which is the visual mark we are going to use to actually represent each observation. In this case, let us use simple points:\n\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point()\n\n\nEven if there is always the temptation to put everything together in a single line, it is a good practice to separate every function and layer in each own line for readability reasons. Also note that position channels x and y are so important that you do not need to name them (i.e. x=displ, y=hwy), but just remember that x comes first. Other channels like color, fill, shape, alpha, size… must be always named.\nAs shown above, it is common practice to add data and mapping to the very function that creates the chart object (see ?ggplot), and in this way they apply as defaults to every single layer we add. It is also possible to delay the mapping and still act as a default as follows:\n\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point()\n\n\nThis is maybe more readable, especially when the mapping is complex, but the result is the same. We can also avoid setting a default dataset and mapping altogether, and just directly plug them into the layers that need them (note that now the order is mapping, then data):\n\n\nggplot() +\n  geom_point(aes(displ, hwy), mpg)\n\n\nHowever, usually we add several layers that refer to the same data, and occasionally some annotation layer that uses another dataset. Therefore, it is generally best to add a default dataset and mapping to avoid duplicated code across layers… or missing ones. For instance, where are the lines here?\n\n\nggplot() +\n  geom_point(aes(displ, hwy), mpg) +\n  geom_line()\n\n\nObviously, there are no lines because they do not have any mapping. It data and mapping are set as defaults, then we have both elements:\n\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point() +\n  geom_line()\n\n\nCheckpoint 2\nHow would you describe the relationship between cty and hwy? Do you have any concerns about drawing conclusions from that plot?\nWhat does ggplot(mpg, aes(model, manufacturer)) + geom_point() show? Is it useful? How could you modify the data to make it more informative?\nDescribe the data, aesthetic mappings and layers used for each of the following plots. You’ll need to guess a little because you haven’t seen all the datasets and functions yet, but use your common sense! See if you can predict what the plot will look like before running the code.\nggplot(mpg, aes(cty, hwy)) + geom_point()\nggplot(diamonds, aes(carat, price)) + geom_point()\nggplot(economics, aes(date, unemploy)) + geom_line()\nggplot(mpg, aes(cty)) + geom_histogram()\n\nMore aesthetics\nTo add additional variables to a plot, we can map them into other channels such as color, shape, or size. For instance, let’s represent the car class as the color of the dots:\n\n\nggplot(mpg) +\n  aes(displ, hwy, color=class) +\n  geom_point()\n\n\nBased on the previous plot, we can see that the group of cars with unusually high fuel economy for their engine size are two seaters: cars with big engines, but lightweight bodies.\nOnce again, we can observe how ggplot2 applies some more sensible defaults:\nIt detects that class is a categorical variable, a factor, and applies a default color scale based on hue.\nAt the same time, the scale is responsible for creating a guide, in this case a legend that shows the class levels along with their associated mapping.\nSometimes it is also useful to split up some aesthetics that may apply only to certain layers. For example, in this case:\n\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  geom_line() +\n  geom_point(aes(color=class))\n\n\nHere, position aesthetics apply to all layers, and color is specific to the layer of points.\nEvery single aesthetic, every single channel, can be set to a fixed value. For instance, if we do not apply any mapping to color, we have previously seen that ggplot2 just draws black dots by default. But of course, this can be changed:\n\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point(color=\"blue\")\n\n\nMastering data mappings is an important skill and you will learn more about it in subsequent tutorials. See vignette(\"ggplot2-specs\") for a comprehensive guide on aesthetics.\nCheckpoint 3\nCompare the following two plots and reason why you get this result:\n\n\nggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = \"blue\"))\nggplot(mpg, aes(displ, hwy)) + geom_point(colour = \"blue\")\n\n\nExperiment with the color, shape and size aesthetics. What happens when you map them to continuous values? What about categorical values? What happens when you use more than one aesthetic in a plot?\nWhat happens if you map a continuous variable to shape? Why? What happens if you map trans to shape? Why?\nHow is drive train related to fuel economy? How is drive train related to engine size and class?\nFaceting\nThis is another fundamental technique for mapping categorical variables. It is most useful e.g. as an alternative to color hue when there are too many categories an no way of further aggregating the data.\nTake for instance the previous class example, with 7 different categories. A solution here is to trade color for position: faceting splits the data in as many subsets as categories in the mapped variable. The only difference with other mappings is that it cannot be applied as an aes(), but directly into the dedicated faceting function, and as a formula, preceded by a ~:\n\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  facet_wrap(~class) +\n  geom_point()\n\n\nCheckpoint 4\nWhat happens if you try to facet by a continuous variable like hwy? What about cyl? What’s the key difference?\nUse faceting to explore the 3-way relationship between fuel economy, engine size, and number of cylinders. How does faceting by number of cylinders change your assessment of the relationship between engine size and fuel economy?\nRead the documentation for facet_wrap(). What arguments can you use to control how many rows and columns appear in the output?\nWhat does the scales argument to facet_wrap() do? When might you use it?\nOutput\nIt should be noted that, with all the code above, we are not only creating chart objects, but also generating and displaying them in one go. This happens with other R objects too: when we do not assign an object to a variable, it is printed. In this case, printing a ggplot means constructing the visual object and displaying it. But of course, as with any other R object, we can save it in a variable and print it later:\n\n\np <- ggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point()\nprint(p)\np # print is implicit\n\n\nWe can even build it step by step:\n\n\np <- ggplot(mpg)\np\np <- p + aes(displ, hwy)\np\np <- p + geom_point()\np\n\n\nOr using different variables:\n\n\np_base <- ggplot(mpg)\np_aes <- aes(displ, hwy)\np_dot <- geom_point()\np_base + p_aes + p_dot\n\n\nThis is convenient for interactive usage or reports as this one. But at other times we might want to produce a graph in a script and save it somewhere else as a standalone image or PDF. This is achieved with the ggsave() function:\n\n\nggsave(\"plot.png\", p, width = 5, height = 5)\n\n\nCheckpoint 5\nRead the documentation for ggsave(). What happens if you do not specify the plot argument?\nHow can you save the plot as a PDF file?\nHow can you modify the proportions of the plot?\nWhat happens if you change the resolution for a PNG output? And a SVG?\n\n\n\n",
    "preview": "tutorials/01/preview.png",
    "last_modified": "2022-10-07T22:11:40+02:00",
    "input_file": {},
    "preview_width": 1050,
    "preview_height": 600
  },
  {
    "path": "tutorials/02/",
    "title": "02. Scales and Guides",
    "description": "Scales are responsible for turning your mapping from data to aesthetics into\nsomething that you can see, and they also provide the guides that let you\ninterpret the plot: axes and legends. Scales are automatically inferred based\non the input data, and guides are added as well based on the layers in your\nplot, which is convenient and saves a lot of time. However, sometimes it is\nrequired to fine-tune how the mapping is performed, or how the guide should\nlook like. This tutorial explores the tools available for this.",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Chapter 2"
    ],
    "contents": "\n\nContents\nScale specification\nScale names\nLimits\nBreaks and labels\nGuides\nTransformations\n\nSource: _tutorials/02/02.Rmd\nScale specification\nWhile geoms represent visual objects (points, lines…), a scale is a procedure that actually performs the mapping of data attributes into the properties of those visual objects (position, color, size…). On the other hand, a guide is a visual cue that allows us to perform the inverse procedure: converting their properties back to data.\n\n\nlibrary(ggplot2)\n\n# convert number of cylinders to factor (only 3 levels)\nmtcars$Cylinders <- as.factor(mtcars$cyl)\n\np <- ggplot(mtcars) +\n  aes(mpg, wt) +\n  geom_point(aes(color=Cylinders))\np\n\n\nCommon components of axes and legends. Figure from the ggplot2 book.In the example above, two position scales (x and y)\ndetected that the data (mpg and wt) is continuous;\nset proper limits to the axes according to the range of data values;\nassigned a position in the chart space to each point according to such coordinates;\nadded the corresponding guides to the axes, including\nnicely and evenly spaced breaks, with tick marks and labels,\ncentered axis labels with the name of the variables.\n\nAdditionally, a color scale\ndetected that the data (Cylinders) is discrete (a categorical variable, a factor);\nassigned a color to each category following a default hue-based scale;\nadded the corresponding guide to the legend, including\nset of keys (colors),\nset of labels (categories in the data),\nlegend title with the name of the variable.\n\nIn other words, the plot above is equivalent to the following:\n\n\np +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_color_discrete()\n\n\nThe last three instructions are just inferred from the data and automatically added. We will only need to specify the scales manually whenever we want to override any of the defaults provided.\nThere are three fundamental scale types:\ncontinuous, for numerical quantities;\ndiscrete, for categorical variables;\nbinned, which is a special type for numerical quantities that first discretize the data.\nBased on these, the fundamental scales, in general, are constructed as follows:\nscale_<aes>_<type>()\nFor example:\nFor aesthetic x and a continuous variable: scale_x_continuous().\nFor aesthetic color and a categorical variable: scale_color_discrete().\nThen there are a bunch of special scales that are shortcuts for specific common tasks, such as scale_x_log10(), which is a continuous scale that also applies a logarithmic transformation, or scale_color_brewer(), which provides a bunch of discrete color schemes from ColorBrewer.\nCheckpoint 1\nTake the first example and assign the original cyl variable to color instead of Cylinders. What happens? Why? What is the scale function that is being applied here? What happens if we try to force scale_color_discrete() in this setting? Why?\nRead the documentation for scale_x_continuous(). How can you change the name of the axis? What happens if we manually specify the same scale twice (try adding different names)? Why?\nHow can you change the position of the axes?\nScale names\nAs you may have discovered in the previous section, all scales have a name argument that is used for the axis label (for position scales) or legend title (for other scales), and which by default prints the name of the variable. There is however a shortcut, a more direct way of setting these labels, via the labs() function.\n\n\np +\n  labs(\n    x = \"Fuel consumption in miles per gallon\",\n    y = \"Weight in thousands of pounds\",\n    color = \"Number of cylinders\"\n  )\n\n\nIn these strings, you can use \\\\n to insert a line break, but you can also supply mathematical expressions and other formatting options wrapped in quote(). See ?plotmath for documentation on which expressions can be used and how they are interpreted.\n\n\nx <- seq(from = -2, to = 2, by = .01)\nggplot(data.frame(x=x, y=x^3)) +\n  aes(x, y) +\n  geom_path() +\n  labs(y = quote(f(x) == x^3))\n\n\nCheckpoint 2\nHow can you remove an axis label, or a legend title?\nRead the documentation for labs(). Investigate what other labels, apart from the aesthetics, can be set with this function. Experiment with them.\nRead the documentation for ?plotmath. How can you set a title with some words in bold, others in italics…? How can you wrap a very long subtitle with line breaks?\nLimits\nScale limits are the region of the data space in which the mapping is defined: for continuous variables, ggplot2 defaults to the range() of the data; for categorical variables, it is just a discrete set of categories. However, you may have noticed that the limits of the axes extend a little bit past the range of the data. This is to ensure that the visual marks do not collide with the axes.\n\n\n# compare\nrange(mtcars$mpg)\nrange(mtcars$wt)\n# with the limits in\np\n\n\nSometimes, this automatic expansion is not desirable. It can be modified by providing an expansion() to the scales’ expand argument. E.g., to remove any expansion:\n\n\np +\n  scale_x_continuous(expand=expansion(0)) +\n  scale_y_continuous(expand=expansion(0))\n\n\nThis is often useful for maps and other area-based plots, but not so much for scatterplots, since it hides some points.\nAs with the name, all scales have a limits argument that can be used to change this default behavior, e.g. to increase the range for continuous variables, or to include some category that is not in our data for categorical variables. And again, this is also so common that there is a shortcut via the lims() function.\n\n\np +\n  lims(\n    x = c(0, 50),\n    y = c(0, 10),\n    color = factor(c(2, 4, 6, 8, 10))\n  )\n\n\nIn the plot above we increased the limits, but what happens if we try to “zoom-in”?, if we specify a range that leaves “out of bounds” (oob) values falling outside these limits?\n\n\np +\n  lims(\n    x = c(20, 25),\n    y = c(2, 4)\n  )\n\n\nAs you can see, the default behavior is to censor (by assigning a NA) those out-of-bounds values. Scales have an oob argument to modify this behavior, which default to scales::oob_censor.\n\n\np +\n  scale_x_continuous(limits=c(20, 25), oob=scales::oob_censor) +\n  scale_y_continuous(limits=c(2, 4), oob=scales::oob_censor)\n\n\nCheckpoint 3\nTake the last example and add a geom_smooth() layer. What is the difference between applying the default scales::oob_censor, scales::oob_squish and scales::oob_keep to the position scales?\nWhat happens if you provide a set of levels to the limits of the color scale that does not contain any of the categories present in the data?\nBreaks and labels\nWhen ggplot2’s algorithm to infer the appropriate number of tick marks for axes and legends fails, we can give it a hint using the n.breaks argument.\n\n\np +\n  scale_x_continuous(n.breaks=4)\n\n\nIf that is not good enough for our purposes, another option is to use the breaks argument (maybe in conjunction with minor_breaks) to explicitly set which ones we want.\n\n\np +\n  scale_x_continuous(breaks=c(10, 15, 30, 40), minor_breaks=c(20, 25))\n\n\nNote that the last break, 40, is not shown because it is out of range.\nAdditionally, another common task is to tune the label assigned to each break. This can be accomplished with the labels argument. We can set anything as labels, but these must match the number of breaks, so it is best to specify both at the same time.\n\n\np +\n  scale_x_continuous(breaks=c(10, 15, 30), labels=c(\"ten\", \"fifteen\", \"thirty\"))\n\n\nHelper functions scales::label_*() allow us to format the breaks following some pattern.\n\n\np +\n  scale_y_continuous(labels=scales::label_number(suffix=\"k\"))\n\n\nIn the previous example, we added “k” to indicate that the weight is in thousands of pounds. Other useful functions are scales::label_percent() to format numbers between 0 and 1 as percentages, or scales::label_dollar() to format numbers as currencies.\nCheckpoint 4\nModify the breaks and labels for the color scale in the previous plot. What happens if a category present in the data is dropped compared to what happens for the limits argument?\nGuides\nSo far we have been talking about scale names, breaks and labels, but they are really properties of the guides, axes and legends, which are the visual cues that allows us to interpret the visual objects and transform them back into data. Guides can be set, unset or fine-tuned using the guide argument, or via the special function guides(), which works similarly to labs() and lims().\n\n\np +\n  guides(\n    x = guide_axis(position=\"top\", angle=45),\n    color = guide_legend(reverse=TRUE)\n  )\n\n\nSee ?guide_axis, ?guide_legend and the more specific ?guide_colorbar for more options.\nTransformations\nScale transformations are specified using the trans argument. They transform the mapping without transforming the data. The most common use case is to adjust a continuous scale using some non-linear transformation to emphasize some values in the data that are hard to see in linear scale.\n\n\np +\n  scale_x_continuous(trans=\"log10\")\n\n\nSome common transformations, such as the logarithmic scale, have dedicated functions.\n\n\np +\n  scale_x_log10()\n\n\nCheckpoint 5\nCompare the last example with ggplot(mtcars) + aes(log10(mpg), wt) + geom_point(aes(color=Cylinders)). What are the differences? Why?\nRead the documentation for scale_x_continuous() and investigate how to do this. What is the default transformation? What does the \"reverse\" transformation do?\n\n\n\n",
    "preview": "tutorials/02/scale-guides.png",
    "last_modified": "2022-10-09T22:06:36+02:00",
    "input_file": {},
    "preview_width": 744,
    "preview_height": 367
  },
  {
    "path": "tutorials/03/",
    "title": "03. Coordinate Systems",
    "description": "The meaning of position aesthetics and how they produce a 2D position on the\nplot depend on the coordinate system. This is also responsible for drawing\nthe axes and panel backgrounds (grid lines, etc.). As with scales, Cartesian\ncoordinates are applied by default unless stated otherwise, which preserves\nthe common meaning of x and y.",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Chapter 2"
    ],
    "contents": "\n\nContents\nCartesian coordinates\nHow to make a pie\nTransformations\nMaps\n\nSource: _tutorials/03/03.Rmd\nCartesian coordinates\nMost of the plots we know and love use Cartesian coordinates, where the position of an element is given by orthogonal distances, x and y, to an origin.\n\n\nlibrary(ggplot2)\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point(aes(color=class))\n\n\nEven when one of the axis is a categorical variable, the same concept of “distance to an origin” applies, because internally those categories are mapped to positions 1, 2, 3…\n\n\nggplot(mpg) +\n  aes(displ, class) +\n  geom_col() +\n  geom_text(aes(label=class), data.frame(\n    displ = 200, class = c(1, 2, 3, 4, 5, 6, 7)\n  ))\n\n\nAs with scales, coord_cartesian() is the default, and it does not need to be explicitly specified to produce a plot. However, this function has some useful options that makes some things easier. Particularly, you may recall from the previous tutorial that zooming in by setting the limits of a scale by default censors points that are out of bounds (meaning that they are marked as missing with a NA). For scales, an additional argument oob must be specified in order to keep those points (e.g. for smoothing calculations). In contrast, coord_cartesian() provides limits that do not censor data. Therefore, the following plots are equivalent:\n\n\np <- ggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point(aes(color=class)) +\n  geom_smooth()\n\np +\n  scale_x_continuous(limits=c(3, 4), oob=scales::oob_keep) +\n  scale_y_continuous(limits=c(20, 30), oob=scales::oob_keep)\n\np +\n  coord_cartesian(xlim=c(3, 4), ylim=c(20, 30))\n\n\nCheckpoint 1\nFunction coord_flip() comes in handy to exchange the x and y axes. Take the first example and add geom_smooth(method=\"lm\"). What is the difference between adding coord_flip() and directly exchanging the x and y mapping in the aes()? Why?\nTake the first example and add coord_fixed(). Then use variable cty instead of displ to compare. What does this function do? What could be a good use case for this?\nHow to make a pie\nA pie chart is just a single stacked bar in polar coordinates. For instance, take this one:\n\n\np <- ggplot(mpg) +\n  aes(\"cars\", fill=class) +\n  geom_bar()\np\n\n\nThen, we just need to fold it using y (the count produced by geom_bar) as the angle:\n\n\np + coord_polar(theta=\"y\")\n\n\nSo much effort for such a meaningless visualization. :)\nTransformations\nTransformations can be performed at two levels: at the scale level, via the trans argument to the scale functions (or the dedicated scales such as scale_x_log10()), or at the coordinate system level, via coord_trans(). The only difference is that the first ones occur before any statistics are computed, while the second ones occur after those.\nCheckpoint 2\nTake the first example and add geom_smooth(method=\"lm\"). What is the difference between adding scale_x_log10() and adding coord_trans(x=\"log10\")? Why?\nMaps\nFinally, an important family of coordinate systems are map projections. Enter the fascinating world of how to map a sphere to a plane.\n\n\np <- ggplot(map_data(\"world\")) +\n  aes(long, lat, group=group) +\n  geom_path()\n\np # No projection specified, simply long, lat as x, y\np + coord_map(xlim=c(-180, 180)) # Mercator projection by default\np + coord_map(\"orthographic\", xlim=c(-180, 180))\np + coord_map(\"sinusoidal\", xlim=c(-180, 180))\n\n\nSee ?mapproj::mapproject for more info about projections.\nCheckpoint 3\nClick “Zoom” in the plot panel for each of the four plots proposed above. What happens if you stretch and shrink the width of the plot panel in each case? Why?\n\n\n\n",
    "preview": "tutorials/03/preview.png",
    "last_modified": "2022-10-19T19:36:52+02:00",
    "input_file": {},
    "preview_width": 1050,
    "preview_height": 675
  }
]
